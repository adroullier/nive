#----------------------------------------------------------------------
# Poolyx CMS
# Copyright (C) 2012  Arndt Droullier, DV Electric, info@dvelectric.com
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#----------------------------------------------------------------------

__doc__ = ""


import os, sys
import string, time, cPickle, re, types

from Poolyx.utils.path import DvPath
from Poolyx.utils.dateTime import DvDateTime

MYSQL = 0
SQLITE3 = 0

try:    
    import sqlite3
    SQLITE3 = 1
except:
    pass

try:    
    import MySQLdb
    MYSQL = 1
except:    
    pass 
    #print "MySQLdb not imported!"



class MySQLManager(object):
    """
    """

    modifyColumns = True

    def __init__(self):
        import MySQLdb
        self._pDB = None
        self._pDBConn = None
        self.engine = "MyISAM"
        self.useUtf8 = True

    #[s] Database Options ---------------------------------------------------------------------

    def Connect(self, inDatabaseName = "", inIP = "", inUser = "", inPW = ""):
        self._pDBConn = MySQLdb.connect(db = inDatabaseName, host = inIP, user = inUser, passwd = inPW)
        self._pDB = self._pDBConn.cursor()
        return self._pDB != None


    def SetDB(self, inDB):
        self._pDBConn = inDB
        self._pDB = self._pDBConn.cursor()
        return self._pDB != None


    def Close(self):
        self._pDBConn.Close()
        self._pDB.close()
        self._pDB = None


    def IsDB(self):
        return self._pDB != None


    def Bakup(self, dbname, filename, user = "", pw = "", zip = True):
        """
        """
        if sys.platform == "win32":
            if zip:
                cmd = "%s -u %s | gzip > %s" % (dbname, user, filename)
            else:
                cmd = "%s -u %s > %s" % (dbname, user, filename)
            p = DvPath("mysqldump")
            p.Execute(cmd)
        else:
            if zip:
                cmd = "%s -u %s | gzip > %s" % (dbname, user, filename)
            else:
                cmd = "%s -u %s > %s" % (dbname, user, filename)
            p = DvPath("mysqldump")
            p.Execute(cmd)
        return


    #[s] Database Options ----------------------------------------------------------------

    def ConvertDate(self, date):
        return DvDateTime(date).GetDBMySql()


    def CompareStructure(self, inTableName, inStructure):
        aS = self.GetColumns(inTableName)
        if len(aS) != len(inStructure):
            return False
        aCnt = 0
        for aC in aS:
            for aC2 in inStructure:
                if aC[0] != aC2[0]:
                    continue
                if not self._CompareS(aC, aC2):
                    return False
                aCnt += 1
        return aCnt == len(aS)


    def GetChangedColumns(self, inTableName, inStructure):
        """
        inModify = None to skip changing existing columns, list of column ids to modify if changed
        """
        aIsDictList = (type(inStructure[0]) != types.ListType)
        # check table exists
        if not self.IsTable(inTableName):
                return []

        aCols = self.GetColumns(inTableName)
        changed = []
        for aC in inStructure:
            # skip fields beginning with underscore
            if(aC["datatype"][:1] == "_"):
                continue

            # check column exists
            if(aIsDictList):
                aName = aC["id"]
                aOptions = self.ConvertDictToColumnOptions(aC)
            else:
                aName = aC[0]
                aOptions = aC

            # skip id column
            if(aName == "id"):
                continue

            if not self.IsColumn(inTableName, aName):
                changed.append(aName)
                continue

            # check column settings
            for aC2 in aCols:
                if aName != aC2[0]:
                    continue
                aC2 = self.ConvertListToColumnOptions(aC2)
                if not self._CompareS(aOptions, aC2):
                    changed.append(aName)

        return changed


    def UpdateStructure(self, inTableName, inStructure, inModify = None):
        """
        inModify = None to skip changing existing columns, list of column ids to modify if changed
        """
        aIsDictList = (type(inStructure[0]) != types.ListType)
        # check table exists
        if not self.IsTable(inTableName):
            if not self.CreateTable(inTableName, inColumns=inStructure):
                return False
            # delay until table is created
            time.sleep(0.3)
            aCnt = 1
            while not self.IsTable(inTableName):
                time.sleep(0.5)
                aCnt += 1
                if aCnt == 10:
                    BREAK("timeout create table")
                    return False
            return True

        aCols = self.GetColumns(inTableName)

        for aC in inStructure:
            # skip fields beginning with underscore
            if(aC["datatype"][:1] == u"_"):
                continue

            # check column exists
            if(aIsDictList):
                aName = aC["id"]
                aOptions = self.ConvertDictToColumnOptions(aC)
            else:
                aName = aC[0]
                aOptions = aC

            # skip id column
            if(aName == u"id"):
                continue

            if not self.IsColumn(inTableName, aName):
                if not self.CreateColumn(inTableName, aName, aOptions):
                    return False
                continue

            if not inModify:
                continue

            if not aName in inModify:
                continue

            # check column settings
            for aC2 in aCols:
                if aName != aC2[0]:
                    continue
                if not self.ModifyColumn(inTableName, aName, u"", aOptions):
                    return False

        return True


    def ConvertListToColumnOptions(self, inList):
        """
        """
        o = inList[1].upper()
        if inList[2] == u"":
            o += u" NOT NULL"
        else:
            o += u" NULL"
        if inList[4] == u"0000-00-00 00:00:00":
            o += u" DEFAULT ''"
        elif inList[1].upper() == u"TEXT":
            pass
        elif inList[1].upper().find(u"INT") != -1:
            o += u" DEFAULT %s" % (inList[4])
        elif inList[1].upper().find(u"FLOAT") != -1:
            o += u" DEFAULT %s" % (inList[4])
        else:
            o += u" DEFAULT '%s'" % (inList[4])
        return o


    def ConvertDictToColumnOptions(self, inDict):
        """
        field representation:
        {"id": "type", "datatype": "list", "size"/"maxLen": 0, "default": ""}

        datatypes:
        list -> list || listn

        string -> VARCHAR(size) NOT NULL DEFAULT default
        number -> INT NOT NULL DEFAULT default
        float -> FLOAT NOT NULL DEFAULT default
        bool -> TINYINT(4) NOT NULL DEFAULT default
        percent -> TINYINT(4) NOT NULL DEFAULT default
        text -> TEXT NOT NULL DEFAULT default
        htext -> TEXT NOT NULL DEFAULT default
        lines -> TEXT NOT NULL DEFAULT default
        xml -> TEXT NOT NULL DEFAULT default
        unit -> INT NOT NULL DEFAULT default
        unitlist -> VARCHAR(2048) NOT NULL DEFAULT default
        date -> DATE NULL DEFAULT default
        datetime -> DATETIME NULL DEFAULT default
        timestamp -> TIMESTAMP
        listt -> VARCHAR(30) NOT NULL DEFAULT default
        listn -> SMALLINT NOT NULL DEFAULT default
        mselection, mcodelist, mcheckboxes -> VARCHAR(2048) NOT NULL DEFAULT default
        json -> TEXT
        [file] -> BLOB
        [bytesize] -> BIGINT(20) NOT NULL DEFAULT default
        url -> TEXT NOT NULL DEFAULT default
        """
        aType = inDict["datatype"]
        aStr = ""

        # convert datatype list
        if(aType == "list"):
            if type(inDict["default"]) == types.StringType:
                aType = "listt"
            else:
                aType = "listn"

        if aType in ("string", "email", "password"):
            if inDict.get("size", inDict.get("maxLen",0)) <= 3:
                aStr = u"CHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])
            else:
                aStr = u"VARCHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])

        elif(aType in ("number", "long", "int")):
            aN = inDict["default"]
            if aN == u"" or aN == u" " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = long(aN)
            if inDict.get("size", inDict.get("maxLen",0)) == 4:
                aStr = u"TINYINT(4) NOT NULL DEFAULT %d" % (aN)
            elif inDict.get("size", inDict.get("maxLen",0)) >16:
                aStr = u"BIGINT(20) NOT NULL DEFAULT %d" % (aN)
            else:
                aStr = u"INT NOT NULL DEFAULT %d" % (aN)

        elif(aType == "float"):
            aN = inDict["default"]
            if aN == u"" or aN == u" " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = float(aN)
            aStr = u"FLOAT NOT NULL DEFAULT %d" % (aN)

        elif(aType == "bool"):
            aN = inDict["default"]
            if aN == u"" or aN == u" " or aN == None or aN == u"False":
                aN = 0
            if aN == u"True":
                aN = 1
            if type(aN) == types.StringType:
                aN = int(aN)
            aStr = u"TINYINT(4) NOT NULL DEFAULT %d" % (aN)

        elif aType in ("text", "htext", "url", "urllist", "json"):
            aStr = u"TEXT NOT NULL" # DEFAULT '%s'" % (inDict["default"])

        elif(aType == "unit"):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = long(aN)
            aStr = u"INT UNSIGNED NOT NULL DEFAULT %d" % (aN)

        elif(aType == "unitlist"):
            aStr = u"VARCHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])

        elif(aType == "date"):
            aD = inDict["default"]
            if aD == () or aD == "()":
                aD = u"NULL"
            if aD in ("now", "nowdate", "nowtime"):
                aD = u""
            if type(aD) == types.StringType and not aD in ("NOW","NULL"):
                aD = self.ConvertDate(aD)
            if aD == u"":
                aStr = u"DATE NULL"
            else:
                aStr = u"DATE NULL DEFAULT '%s'" % (aD)

        elif(aType == "datetime"):
            aD = inDict["default"]
            if aD == () or aD == "()":
                aD = u"NULL"
            if aD in ("now", "nowdate", "nowtime"):
                aD = u""
            if type(aD) == types.StringType and not aD in ("NOW","NULL"):
                aD = self.ConvertDate(aD)
            if aD == u"":
                aStr = u"DATETIME NULL"
            else:
                aStr = u"DATETIME NULL DEFAULT '%s'" % (aD)

        elif(aType == "timestamp"):
            aStr = u"TIMESTAMP"

        elif(aType == "listt"):
            aStr = u"VARCHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])

        elif(aType == "listn") or (aType == "codelist"):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = int(aN)
            aStr = u"SMALLINT(6) NOT NULL DEFAULT %d" % (aN)

        elif(aType == "mselection") or (aType == "mcheckboxes") or (aType == "mcodelist") or (aType == "radio"):
            aStr = u"VARCHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])

        elif(aType == "file"):
            aStr = u"BLOB"

        elif(aType == "bytesize"):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = long(aN)
            aStr = u"BIGINT(20) NOT NULL DEFAULT %d" % (aN)

        return aStr


    #[s] Database Options ------------------------------------------------------------

    def IsDatabase(self, inDatabaseName):
        for aD in self.GetDatabases():
            if aD[0] == inDatabaseName:
                return True
        return False

    def CreateDatabase(self, inDatabaseName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"create database " + inDatabaseName)
        self._pDBConn.commit()
        return True


    def UseDatabase(self, inDatabaseName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"use " + inDatabaseName)
        return True


    def DeleteDB(self, inDatabaseName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"drop database " + inDatabaseName)
        return True


    #[s] TABLE OPTIONS --------------------------------------------------------------
    """
    inTableEntrys --> ColumnName ColumnDataTyp ColumnOptions
    ColumnOptions --> [NOT][NULL][DEFAULT = ""][PRIMARY KEY][UNIQUE]

    ENGINE = MyISAM
    CHARACTER SET utf8 COLLATE utf8_general_ci;

    ENGINE = InnoDB
    CHARACTER SET utf8 COLLATE utf8_general_ci;
    """

    def IsTable(self, inTableName):
        for aD in self.GetTables():
            if string.lower(aD[0]) == string.lower(inTableName):
                return True
        return False


    def CreateTable(self, inTableName, inColumns = None, inCreateIdentity = True, primaryKeyName="id"):
        if not self.IsDB():
            return False
        if not inTableName or inTableName == "":
            return False
        assert(inTableName != "user")
        aSql = ""
        if inCreateIdentity:
            aSql = u"CREATE TABLE %s(%s INT UNSIGNED AUTO_INCREMENT UNIQUE NOT NULL PRIMARY KEY) AUTO_INCREMENT = 1" % (inTableName, primaryKeyName)
        else:
            aSql = u"CREATE TABLE %s(" % (inTableName)
            if not inColumns:
                raise ConfigurationError, "No database fields defined."
        if inColumns:
            aCnt = 0
            for c in inColumns:
                if aCnt:
                    aSql += u","
                aCnt = 1
                aSql += c.id + u" " + self.ConvertDictToColumnOptions(c)
            aSql += u")"
        aSql += u" ENGINE = %s" %(self.engine)
        if self.useUtf8:
            aSql += u" CHARACTER SET utf8 COLLATE utf8_general_ci"
        self._pDB.execute(aSql)
        # delay until table is created
        time.sleep(0.3)
        aCnt = 1
        while not self.IsTable(inTableName):
            time.sleep(0.5)
            aCnt += 1
            if aCnt == 30:
                return False
        return True


    def RenameTable(self, inTableName, inNewTableName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"alter table %s rename as %s" % (inTableName, inNewTableName))
        return True


    def DeleteTable(self, inTableName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"drop table %s" % (inTableName))
        return True


    #[s] COLUMN OPTIONS --------------------------------------------------------------
    """
    inColumnData --> "ColumnName ColumnDataType ColumnOptions"
        Column Options --> [Not] [NULL] [DEFAULT 'default']
    SetPrimaryKey&SetUnique --> can also get a ColumnList
        ColumnList --> ColumnName1,ColumName2,...
    """

    def IsColumn(self, inTableName, inColumnName):
        for aD in self.GetColumns(inTableName):
            if aD["id"] == inColumnName:
                return True
        return False


    def CreateColumn(self, inTableName, inColumnName, inColumnOptions):
        if not self.IsDB():
            return False
        #print("alter table %s add column %s %s" % (inTableName, inColumnName, inColumnOptions))
        if(inColumnOptions == "" or inColumnName == "" or inTableName == ""):
            return False
        if inColumnOptions == "identity":
            return self.CreateIdentityColumn(inTableName, inColumnName)
        self._pDB.execute(u"alter table %s add column %s %s" % (inTableName, inColumnName, inColumnOptions))
        return True


    def CreateIdentityColumn(self, inTableName, inColumnName):
        if not self.IsDB():
            return False
        return self.CreateColumn(inTableName, inColumnName, u"INT UNSIGNED AUTO_INCREMENT UNIQUE NOT NULL PRIMARY KEY")


    def DeleteColumn(self, inTableName, inColumnName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"alter table %s drop column %s" % (inTableName, inColumnName))
        return True


    def ModifyColumn(self, inTableName, inColumnName, inNewColumnName, inColumnOptions):
        if not self.IsDB():
            return False
        #print("alter table %s change %s %s %s" % (inTableName, inColumnName, inNewColumnName, inColumnOptions))
        if(inColumnOptions == "" or inColumnName == "" or inTableName == ""):
            return False
        aN = inNewColumnName
        if aN == "":
            aN = inColumnName
        self._pDB.execute(u"alter table %s change %s %s %s" % (inTableName, inColumnName, aN, inColumnOptions))
        return True


    #[s] INDEX OPTIONS ---------------------------------------------------------------

    def SetIndexPrimaryKey(self, inTableName, inColumnNames):
        if not self.IsDB():
            return False
        self._pDB.execute(u"alter table %s add primary key %s" % (inTableName, inColumnNames))
        return True


    def SetIndexUnique(self, inTableName, inColumnNames, inIndexName = ""):
        if not self.IsDB():
            return False
        if(inIndexName == ""):
            self._pDB.execute(u"alter table %s add unique(%s)" % (inTableName, inColumnNames))
        else:
            self._pDB.execute(u"alter table %s add unique %s(%s)" % (inTableName, inIndexName, inColumnNames))
        return True


    def AddIndex(self, inTableName, inColumnNames, inIndexName = "", indexType = "INDEX"):
        if not self.IsDB():
            return False
        if(inIndexName == ""):
            self._pDB.execute(u"alter table %s add %s (%s)" % (inTableName, indexType, inColumnNames))
        else:
            self._pDB.execute(u"alter table %s add %s %s(%s)" % (inTableName, indexType, inIndexName, inColumnNames))
        return True


    def DropIndex(self, inTableName, inIndexName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"alter table %s drop index %s" % (inTableName, inIndexName))
        return True


    #[s] SHOW OPTIONS ----------------------------------------------------------------

    def GetDatabases(self):
        if not self.IsDB():
            return ""
        self._pDB.execute(u"show databases")
        return self._pDB.fetchall()


    def GetTables(self, inRaw = True):
        if not self.IsDB():
            return ""
        self._pDB.execute(u"show tables")
        return self._pDB.fetchall()


    def GetColumns(self, inTableName, inRaw = False):
        if not self.IsDB():
            return ""
        self._pDB.execute(u"show columns from %s" % (inTableName))
        aC = self._pDB.fetchall()
        if inRaw:
            return aC
        cols = []
        for c in aC:
            cols.append({"id": c[3]}) #,c[4],c[5],c[11]))
        return cols


    def _CompareS(self, inS1, inS2):
        for i in range(len(inS1)):
            if string.lower(inS1[i - 1]) != string.lower(inS2[i - 1]):
                return False
        return True
    
    
    
class Sqlite3Manager(MySQLManager):
    """
    """
    modifyColumns = True #False

    def __init__(self):
        import sqlite3
        self._pDB = None
        self._pDBConn = None
        self.useUtf8 = True


    def Connect(self, inDatabaseName = ""):
        self._pDBConn = sqlite3.connect(inDatabaseName)
        self._pDB = self._pDBConn.cursor()
        return self._pDB != None


    def SetDB(self, inDB):
        self._pDBConn = inDB
        self._pDB = self._pDBConn.cursor()


    def Close(self):
        self._pDB.close()
        self._pDB = None
        self._pDBConn.close()


    def IsDB(self):
        return self._pDB != None


    def Bakup(self, dbname, filename, user = "", pw = "", zip = True):
        """
        """
        return


    #[s] Database Options ----------------------------------------------------------------

    def ConvertDate(self, date):
        return DvDateTime(date).GetDBMySql()


    def CompareStructure(self, inTableName, inStructure):
        return False


    def GetChangedColumns(self, inTableName, inStructure):
        """
        inModify = None to skip changing existing columns, list of column ids to modify if changed
        """
        return None


    def UpdateStructure(self, inTableName, inStructure, inModify = None):
        """
        inModify = None to skip changing existing columns, list of column ids to modify if changed
        """
        aIsDictList = (type(inStructure[0]) != types.ListType)
        # check table exists
        if not self.IsTable(inTableName):
            if not self.CreateTable(inTableName, inColumns=inStructure):
                return False
            # delay until table is created
            time.sleep(0.3)
            aCnt = 1
            while not self.IsTable(inTableName):
                time.sleep(0.5)
                aCnt += 1
                if aCnt == 10:
                    BREAK("timeout create table")
                    return False
            return True

        aCols = self.GetColumns(inTableName)

        for aC in inStructure:
            # skip fields beginning with underscore
            if(aC["datatype"][:1] == "_"):
                continue

            # check column exists
            if(aIsDictList):
                aName = aC["id"]
                aOptions = self.ConvertDictToColumnOptions(aC)
            else:
                aName = aC[0]
                aOptions = aC

            # skip id column
            if(aName == "id"):
                continue

            if not self.IsColumn(inTableName, aName):
                if not self.CreateColumn(inTableName, aName, aOptions):
                    return False
                continue

            if not inModify:
                continue

            if not aName in inModify:
                continue

            # check column settings
            for aC2 in aCols:
                if aName != aC2["id"]:
                    continue
                if not self.ModifyColumn(inTableName, aName, "", aOptions):
                    return False

        return True


    def ConvertListToColumnOptions(self, inList):
        """
        """
        o = inList[1].upper()
        if inList[2] == u"":
            o += u" NOT NULL"
        else:
            o += u" NULL"
        if inList[4] == u"0000-00-00 00:00:00":
            o += u" DEFAULT ''"
        elif inList[1].upper() == u"TEXT":
            pass
        elif inList[1].upper().find("INT") != -1:
            o += u" DEFAULT %s" % (inList[4])
        elif inList[1].upper().find("FLOAT") != -1:
            o += u" DEFAULT %s" % (inList[4])
        else:
            o += u" DEFAULT '%s'" % (inList[4])
        return o


    def ConvertDictToColumnOptions(self, inDict):
        """
        field representation:
        {"id": "type", "datatype": "list", "size"/"maxLen": 0, "default": ""}

        datatypes:
        list -> list || listn

        string -> VARCHAR(size) NOT NULL DEFAULT default
        number -> INT NOT NULL DEFAULT default
        float -> FLOAT NOT NULL DEFAULT default
        bool -> TINYINT(4) NOT NULL DEFAULT default
        percent -> TINYINT(4) NOT NULL DEFAULT default
        text -> TEXT NOT NULL DEFAULT default
        htext -> TEXT NOT NULL DEFAULT default
        lines -> TEXT NOT NULL DEFAULT default
        xml -> TEXT NOT NULL DEFAULT default
        unit -> INT NOT NULL DEFAULT default
        unitlist -> VARCHAR(2048) NOT NULL DEFAULT default
        date -> TIMESTAMP NULL DEFAULT default
        datetime -> TIMESTAMP NULL DEFAULT default
        timestamp -> TIMESTAMP
        listt -> VARCHAR(30) NOT NULL DEFAULT default
        listn -> SMALLINT NOT NULL DEFAULT default
        mselection, mcodelist, mcheckboxes -> VARCHAR(2048) NOT NULL DEFAULT default
        [file] -> BLOB
        [bytesize] -> BIGINT(20) NOT NULL DEFAULT default
        url -> TEXT NOT NULL DEFAULT default
        """
        aType = inDict["datatype"]
        aStr = u""

        # convert datatype list
        if(aType == "list"):
            if type(inDict["default"]) == types.StringType:
                aType = "listt"
            else:
                aType = "listn"

        if aType in ("string", "email", "password"):
            if inDict.get("size", inDict.get("maxLen",0)) <= 3:
                aStr = u"CHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])
            else:
                aStr = u"VARCHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])

        elif(aType in ("number", "long", "int")):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = long(aN)
            if inDict.get("size", inDict.get("maxLen",0)) == 4:
                aStr = u"TINYINT NOT NULL DEFAULT %d" % (aN)
            elif inDict.get("size", inDict.get("maxLen",0)) in (11,12):
                aStr = u"INTEGER NOT NULL DEFAULT %d" % (aN)
            else:
                aStr = u"INTEGER NOT NULL DEFAULT %d" % (aN)

        elif(aType == "float"):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = float(aN)
            aStr = u"FLOAT NOT NULL DEFAULT %d" % (aN)

        elif(aType == "bool"):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None or aN == "False":
                aN = 0
            if aN == "True":
                aN = 1
            if type(aN) == types.StringType:
                aN = int(aN)
            aStr = u"TINYINT NOT NULL DEFAULT %d" % (aN)

        elif aType in ("text", "htext", "url", "urllist"):
            aStr = u"TEXT NOT NULL DEFAULT '%s'" % (inDict["default"])

        elif(aType == "unit"):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = long(aN)
            aStr = u"INTEGER NOT NULL DEFAULT %d" % (aN)

        elif(aType == "unitlist"):
            aStr = u"VARCHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])

        elif(aType == "date"):
            aD = inDict["default"]
            if aD == () or aD == "()":
                aD = "NULL"
            if aD in ("now", "nowdate", "nowtime"):
                aD = ""
            if type(aD) == types.StringType and not aD in ("NOW","NULL"):
                aD = self.ConvertDate(aD)
            if aD == "":
                aStr = u"TIMESTAMP NULL"
            else:
                aStr = u"TIMESTAMP NULL DEFAULT '%s'" % (aD)

        elif(aType == "datetime"):
            aD = inDict["default"]
            if aD == () or aD == "()":
                aD = "NULL"
            if aD in ("now", "nowdate", "nowtime"):
                aD = ""
            if type(aD) == types.StringType and not aD in ("NOW","NULL"):
                aD = self.ConvertDate(aD)
            if aD == "":
                aStr = u"TIMESTAMP NULL"
            else:
                aStr = u"TIMESTAMP NULL DEFAULT '%s'" % (aD)

        elif(aType == "timestamp"):
            aStr = u"TIMESTAMP DEFAULT (datetime('now','localtime'))"

        elif(aType == "listt"):
            aStr = u"VARCHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])

        elif(aType == "listn") or (aType == "codelist"):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = int(aN)
            aStr = "SMALLINT NOT NULL DEFAULT %d" % (aN)

        elif(aType == "mselection") or (aType == "mcheckboxes") or (aType == "mcodelist") or (aType == "radio"):
            aStr = u"VARCHAR(%d) NOT NULL DEFAULT '%s'" % (inDict.get("size", inDict.get("maxLen",0)), inDict["default"])

        elif(aType == "file"):
            aStr = u"BLOB"

        elif(aType == "bytesize"):
            aN = inDict["default"]
            if aN == "" or aN == " " or aN == None:
                aN = 0
            if type(aN) == types.StringType:
                aN = long(aN)
            aStr = u"INTEGER NOT NULL DEFAULT %d" % (aN)

        return aStr



    #[s] SHOW OPTIONS ----------------------------------------------------------------

    def GetDatabases(self):
        return []


    def GetTables(self, inRaw = True):
        if not self.IsDB():
            return []
        sql = u"""SELECT name FROM 
                   (SELECT * FROM sqlite_master UNION ALL
                    SELECT * FROM sqlite_temp_master)
                WHERE type='table'
                ORDER BY name"""
        self._pDB.execute(sql)
        return self._pDB.fetchall()


    def GetColumns(self, inTableName, inRaw = False):
        if not self.IsDB():
            return ""
        sql = u"""PRAGMA table_info(%s)"""
        self._pDB.execute(sql % (inTableName))
        aC = self._pDB.fetchall()
        if inRaw:
            return aC
        cols = []
        for c in aC:
            # (0, u'id', u'INTEGER', 0, None, 1)
            # (1, u'cssClass', u'VARCHAR(10)', 1, u"''", 0)
            cols.append({"id": c[1], "type": c[2], "identity": c[5], "default": c[4], "null": c[3]}) 
        return cols


    #[s] TABLE OPTIONS --------------------------------------------------------------
    """
    inTableEntrys --> ColumnName ColumnDataTyp ColumnOptions
    ColumnOptions --> [NOT][NULL][DEFAULT = ""][PRIMARY KEY][UNIQUE]
    """

    def IsTable(self, inTableName):
        for aD in self.GetTables():
            if string.lower(aD[0]) == string.lower(inTableName):
                return True
        return False


    def CreateTable(self, inTableName, inColumns = None, inCreateIdentity = True, primaryKeyName="id"):
        if not self.IsDB():
            return False
        if not inTableName or inTableName == "":
            return False
        assert(inTableName != "user")
        aSql = u""
        if inCreateIdentity:
            aSql = u"CREATE TABLE %s(%s INTEGER PRIMARY KEY AUTOINCREMENT" % (inTableName, primaryKeyName)
            if inColumns:
                for c in inColumns:
                    if c.id == primaryKeyName:
                        continue
                    aSql += ","
                    aSql += c.id + u" " + self.ConvertDictToColumnOptions(c)
            aSql += u")"
        else:
            aSql = u"CREATE TABLE %s" % (inTableName)
            if not inColumns:
                raise ConfigurationError, "No database fields defined."
            aCnt = 0
            aSql += u"("
            for c in inColumns:
                if aCnt:
                    aSql += u","
                aCnt = 1
                aSql += c.id + u" " + self.ConvertDictToColumnOptions(c)
            aSql += u")"
        self._pDB.execute(aSql)
        # delay until table is created
        time.sleep(0.3)
        aCnt = 1
        while not self.IsTable(inTableName):
            time.sleep(0.5)
            aCnt += 1
            if aCnt == 30:
                return False
        return True


    def RenameTable(self, inTableName, inNewTableName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"alter table %s rename to %s" % (inTableName, inNewTableName))
        return True


    def DeleteTable(self, inTableName):
        if not self.IsDB():
            return False
        self._pDB.execute(u"drop table %s" % (inTableName))
        return True


    #[s] COLUMN OPTIONS --------------------------------------------------------------
    """
    inColumnData --> "ColumnName ColumnDataType ColumnOptions"
        Column Options --> [Not] [NULL] [DEFAULT 'default']
    SetPrimaryKey&SetUnique --> can also get a ColumnList
        ColumnList --> ColumnName1,ColumName2,...
    """

    def IsColumn(self, inTableName, inColumnName):
        for aD in self.GetColumns(inTableName):
            if aD["id"] == inColumnName:
                return True
        return False


    def CreateColumn(self, inTableName, inColumnName, inColumnOptions=""):
        if not self.IsDB():
            return False
        if inColumnName == "" or inTableName == "":
            return False
        if inColumnOptions == "identity":
            return self.CreateIdentityColumn(inTableName, inColumnName)
        self._pDB.execute(u"alter table %s add column %s %s" % (inTableName, inColumnName, inColumnOptions))
        return True


    def CreateIdentityColumn(self, inTableName, inColumnName):
        if not self.IsDB():
            return False
        return self.CreateColumn(inTableName, inColumnName, u"INTEGER PRIMARY KEY AUTOINCREMENT")


    def DeleteColumn(self, inTableName, inColumnName):
        return False


    def ModifyColumn(self, inTableName, inColumnName, inNewColumnName, inColumnOptions):
        return False


    #[s] Database Options ------------------------------------------------------------

    def IsDatabase(self, inDatabaseName):
        try:
            db = sqlite3.connect(inDatabaseName)
            db.close()
            return True
        except:
            return False

    def CreateDatabase(self, inDatabaseName):
        return False

    def UseDatabase(self, inDatabaseName):
        return False

    def DeleteDB(self, inDatabaseName):
        return False
